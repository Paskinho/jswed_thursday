api.js

const api = {
    sendStudentsCountToItKamasutra(studentsCount) {
        return axios.post("https://it-kamasutra.com/students-need", 
        { count: studentsCount });
    },
    getVacanciesCountFromMicrosoft() {
        return axios.get("https://microsoft.com");
    },
    getVacanciesCountFromGoogle() {
        return axios.get("https://google.com");
    }
}

api-15.js


const api = {
    sendStudentsCountToItKamasutra(studentsCount) {
        return axios.post("https://it-kamasutra.com/students-need",
            { count: studentsCount })
            .then(res => res.data);
    },
    getVacanciesCountFromMicrosoft() {
        return axios.get("https://microsoft.com")
            .then(res => res.data);
    },
    getVacanciesCountFromGoogle() {
        return axios.get("https://google.com")
            .then(res => res.data);
    }
}

axios.js

const axios = {
    _fake(url, data) {
        return new Promise( (resolve) => {
            setTimeout(() => {
                let responseData = {
                    text: `${url} loves you` 
                };
                if (url.indexOf('it-kamasutra') > 0) {
                    responseData = {
                        requestedCount: data.count,
                        message: "we will prepare students for you"                        
                    }   
                } else if (url.indexOf('google') > 0) {
                    responseData = {
                        vacancies: 12 
                    }
                } else if (url.indexOf('microsoft') > 0) {
                    responseData = {
                        vacancies: 21 
                    }
                } 
                resolve({
                    request: {},
                    status: 200,
                    headers: {},
                    config: {},
                    data: responseData
                })
            }, randomIntFromInterval(1,5)*1000);
        });
    },

    post(url, data) {
        return this._fake(url, data);
    },
    get(url, data) {
       return this._fake(url, data);
    }
}

function randomIntFromInterval(min, max) { // min and max included 
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  
  
 index.html
 
 1 задание
 
 <script>
 // внутрь Promise передаем колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.
    let myPromise = new Promise((resolve, reject) => {
        console.log(1)
        console.log(2)
        console.log(3)
        resolve()
    });


    // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
    myPromise.then(( ) => {
        console.log("myPromise resolved and i found out about it");
    })
</script>
  
  4 задание 
  
  axios.get('https://google.com/blabla')
      .then( (res) => { console.log(res); } )

Давайте подписчику на наш промис отправим рандомно сгенерированное число. Для этого всего навсего нужно отправить это число в функцию resolve

Удалите alert из тела обещания-колбека, пусть промис просто теперь обещает сгенерировать рандомное число и отправить его подписчикам. Исправьте подписчик, добавив в него параметр number (название параметру можно дать любое) и внутри подписчика выведите это число в консоль. Обновляйте страницу, и в консоли каждый раз будете видеть новое число:

  
  <meta charset="UTF-8"/>
<script>
    // внутрь Promise передаем колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.
    let myPromise = new Promise((resolve, reject) => {
        setTimeout (()=>{
            resolve(Math.random())
        }, 2000)
        console.log(1)
        console.log(2)
        console.log(3)

    });


    // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
    myPromise.then(( res) => {
        console.log("myPromise resolved and i found out about it" + res);
    })
</script>
  
  5 задание
  
  Чаще всего промис не создают как бы так просто, чтобы тут же на него подписываться. Чаще всего у нас есть какая-то функция, мы её вызываем, и она внутри себя создаёт новый промис и возвращает его нам (на подобие axios.get, axios.post и так далее)

Давайте создадим функцию doAfter, которая:
1. … принимает параметром кол-во секунд, сколько ждать
2. … внутри себя будет создавать Promise, обещание которого - просто ждать переданное на этапе 1 кол-во секунд и резолвится через это время.
3. ... возвращает созданный промис наружу.


И когда у нас будет такая функция, мы сможем ей вот так вот пользовать (как заменой setTimeout):

doAfter(5).then( () => console.log('я сработал через 5 секунд') );
doAfter(3).then( () => console.log('а я сработал через 3 секунд') );
doAfter(10).then( () => console.log('я сработал через 10 секунд') );



<meta charset="UTF-8"/>
<script>
    // внутрь Promise передаем колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.
    let myPromise = new Promise((resolve, reject) => {
        setTimeout (()=>{
            resolve(Math.random())
        }, 2000)
        console.log(1)
        console.log(2)
        console.log(3)

    });

    console.log(myPromise)

    const doAfter = (sec)=> {
        if (sec === 5) {
        let myPromise = new Promise((resolve, reject) => {
            setTimeout (()=>{
                const randValue = Math.random()
                resolve(randValue)
            }, 5000)
        });

        return myPromise
        }
        else if (sec === 3) {
            let myPromise = new Promise((resolve, reject) => {
                setTimeout (()=>{
                    const randValue = Math.random()
                    resolve(randValue)
                }, 3000)
            });
            return myPromise
        }
        else if (sec === 10) {
            let myPromise = new Promise((resolve, reject) => {
                setTimeout (()=>{
                    const randValue = Math.random()
                    resolve(randValue)
                }, 10000)
            });
            return myPromise
        }

    }

    // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
    doAfter(5).then( () => console.log('я сработал через 5 секунд') );
    doAfter(3).then( () => console.log('а я сработал через 3 секунд') );
    doAfter(10).then( () => console.log('я сработал через 10 секунд') );

</script>
 
 КОРОТКАЯ ЗАПИСЬ 5 ЗАДАНИЯ 
 
  const doAfter = (sec)=> {
            let myPromise = new Promise((resolve, reject) => {
                setTimeout (()=>{
                    const randValue = Math.random()
                    resolve(randValue)
                }, sec*1000)
            });
            return myPromise


    }

    // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
    doAfter(5).then( () => console.log('я сработал через 5 секунд') );
    doAfter(3).then( () => console.log('а я сработал через 3 секунд') );
    doAfter(10).then( () => console.log('я сработал через 10 секунд') );
  
  
  10 ЗАДАНИЕ
  
  let promise1 = doAfter(1)

    let pr2= promise1.then((n)=>console.log(n))
    let pr3 = pr2.then();
    let pr4 = pr3.then(()=>console.log(3))
    
    console.log('finish', pr2,pr3,pr4)
 
